# Authors:
# - Presumably written by some combination of Michael, Juan
#   Jay, and Aaron
# - Comments / Modifications by Shayne

# Purpose:
# This script continues parsing the ModBase raw download
# from modbase_DL.py. In this step, all of the valid header
# files from modbase_02.py are consolidated into two files;
# a all model summary, and a select model summary, contianing
# non-redundant, high quality models. Models are deemed
# redundant when there is another model for the same PDB
# template that completely encompasses the model in question
# and this larger model has a better MPQS score.

# Expected Outcomes:
# The two model header summary files should be updated to
# be representative of all of the UniProt IDs / models
# contained in the most recent ModBase download.

# Known Bugs:
# - No bugs, questions about definition of redundancy, and
#   possible places to add warnings.

# File Headers (I think this is because this
# script was copied out of the nightly_scripts
# to create a stand alone Eclair ModBase library
#
#!/usr/bin/env python
#DEPENDENCIES: modbase_02.py
#
#EMAIL_LOG:
#EMAIL_ERR: mjm659@cornell.edu

'''Compiles header summary files
(1) all_modbase_models.txt
(2) select_modbase_models.txt   (non-redundant, MPQS >=1.1)'''

# Fixed input directory for headers
headersDir = 'models/headers'

# Fixed ouput files
all_file = 'models/parsed/all_modbase_models.txt'
m3D_file = 'models/parsed/select_modbase_models.txt'

# Imports
import glob, os, sys

# Obtain all of the headers for the valid models
all_header_files = glob.glob(os.path.join(headersDir, '*.txt'))

# Keep running list of final output liens
all_modbase_models = []
m3D_modbase_models = []


# With we generate the complete dataset
# of all lines

# Read the contents all of header files
for f in all_header_files:
	all_modbase_models.append(open(f).read().strip().split('\t'))

# Sort liens
all_modbase_models.sort()


# Then we generate a non-redundant set
# 1) Wherever we have the same pdb / range of
#   indices, we will pick one model with the highest
#   MPQS to represent them all.
#
# 2) We will remove all models that are below
#    our threshold for reliability. The cuttoffs
#    we use are supposedly less strict that modbase's
#    recommendation because we value coverage.


# We maintain a dictionary that maps PDB template
# ranges to their model / scores. We can use a sorted
# version of this dictionary to select the single model
# with the best MPQS for each PDB / target range
#
# keys = (uniprot, pdb, target_begin, target_end)
# values = [(mpqs1, hash1), (mpqs2, hash2)... etc]
#
# I don't think these key:value lists are quite accurate?
# They were generated by a previous comment, but do not
# appear to reflect the current code.
filter_dict = {}

# Iterate through each header
for l in all_modbase_models:
	# Parse Header
	uniprot,template_length,target_length,pdb,begin,end,sequence_identity,model_score,MPQS,zDOPE,eVALUE,hash_ID = l
	
	# Skip entries with improperly formatted MPQS Score
	# Throw warning?
	try:
		MPQS = float(MPQS)
	except:
		continue
	
	# Skip entries with improperly formatted target start
	# Throw warning?
	try:
		begin = float(begin)
	except:
		continue
	
	# Skip entries with improperly formatted target end
	# Throw warning?
	try:
		end = float(end)
	except:
		continue
	
	# Skip entries with insufficients MPQS Score
	if MPQS < 1.1:
		continue
	
	# If this UniProt / PDB pair has not been
	# encountered before, add to dictionary
	if (uniprot,pdb) not in filter_dict:
		filter_dict[(uniprot, pdb)] = []
	
	# Update Dictionary
	filter_dict[(uniprot, pdb)].append((begin, end, MPQS, hash_ID))


# Keep track of all model IDs
m3D_hash_IDs = set()

# Keep track of models that are competely redundant
# The entirity of this model is contained within
# another model (only if lower MPQS score?)
m3D_redundant_hash = set()

# Iterate through the dictionary of (UniProt, PDB) keys
for f in filter_dict:
	# Iterate over all of the modesl that represent this
	# UniProt using a specific PDB
	for m in filter_dict[f]:
		# Parse Values
		model_start1 = m[0]
		model_end1 = m[1]
		model_mpqs1 = m[2]
		model_hash1 = m[3]
		
		# Add ID to set
		m3D_hash_IDs.add(model_hash1)
		
		# Iterate over all of the models
		for m2 in filter_dict[f]:
			# Parse Values
			model_start2 = m2[0]
			model_end2 = m2[1]
			model_mpqs2 = m2[2]
			model_hash2 = m2[3]
			
			# Skip cases comparing a model to itselt
			if model_hash1==model_hash2:
				continue
			
			# If model1 is completely encompasses by model2 and does
			# not have a better MPQS score, then it is redundant.
			#
			# e.g.   In the alignment below, Model2 makes Model1 redundant since
			#        it fully encompasses Model1 and has a higher MPQS score
			#
			#                         10         20         30         40         50
			#        Target:	MAAARATTPA DGEEPAPEAE ALAAARERSS RFLSGLELVK QGAEARVFRG
			#        Model1:	---------- |||||||||| |||||||||| |||------- ----------   2.3
			#        Model2:  -------||| |||||||||| |||||||||| ||||||||-- ----------	3.0 
			#      
			if model_start1 >= model_start2 and model_end1 <= model_end2 and model_mpqs1 <= model_mpqs2:
				# EDIT: 2021_08_09 - Shayne Wierbowski
				# Don't add this to the redundant set if the model being compared against is already redundant
				# Avoid issues where there is an exact tie
				if(not model_hash2 in m3D_redundant_hash):
					m3D_redundant_hash.add(model_hash1)


# Obtain the headers for all of the non-redundant
# models
m3D_modbase_models = [header for header in all_modbase_models if header[-1] in m3D_hash_IDs and header[-1] not in m3D_redundant_hash]

# Print some statistics
unique_proteins = set([l[0] for l in all_modbase_models])
print 'In all_modbase_models.txt: %s models covering %s unique proteins' %(len(all_modbase_models), len(unique_proteins))

unique_proteins = set([l[0] for l in m3D_modbase_models])
print 'In select_modbase_models.txt: %s models covering %s unique proteins' %(len(m3D_modbase_models), len(unique_proteins))

# Column Names
header = 'uniprot	template_length	target_length	template_pdb	target_begin	target_end	sequence_identity	model_score	modpipe_quality_score	zDOPE	eVALUE	modbase_modelID'.split()

# Write all models header summary
handle = open(all_file, 'w')
handle.write('\t'.join(header)+'\n')
for l in all_modbase_models:
	handle.write('\t'.join(l)+'\n')
handle.close()

# Write non-redundant, high quality
# models header summary
handle = open(m3D_file, 'w')
handle.write('\t'.join(header)+'\n')
for l in m3D_modbase_models:
	handle.write('\t'.join(l)+'\n')
handle.close()
